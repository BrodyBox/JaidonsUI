-- Thanks to Pare and Typical
-- Screw linkvertise

local headmove = true
change = .85
movement = 12
mode = 1
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-18,0,-18)
		end)
	end
end
if headmove == false then
	function LoadLibrary(a)
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/BrodyBox/JaidonsUI/main/Library", true))()
	end
	loadstring(game:HttpGet('https://raw.githubusercontent.com/BrodyBox/JaidonsUI/main/_l',true))();
	wait(0.2)
else
end
if headmove == true then
	HumanDied = false
	local CountSCIFIMOVIELOL = 1
	function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
		local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 5772000--67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 5772000
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
		local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
		AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
		AttachmentA.Position = Position or Vector3.new(0,0,0)
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentA;
		AlignOri.Attachment0 = AttachmentB;
		CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
		return {AlignPos,AlignOri,AttachmentA,AttachmentB}
	end

	if _G.netted ~= true then
		_G.netted = true
		coroutine.wrap(function()
			settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
			settings().Physics.AllowSleep = false
			game:GetService("RunService").RenderStepped:Connect(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
				sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
			end)
		end)()
	end

	game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
	local hatnameclone = {}
	for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
		if v:IsA("Accessory") then
			if hatnameclone[v.Name] then
				if hatnameclone[v.Name] == "s" then
					hatnameclone[v.Name] = {}
				end
				table.insert(hatnameclone[v.Name],v)
			else
				hatnameclone[v.Name] = "s"
			end
		end
	end
	for _,v in pairs(hatnameclone) do
		if type(v) == "table" then
			local num = 1
			for _,w in pairs(v) do
				w.Name = w.Name..num
				num = num + 1
			end
		end
	end
	hatnameclone = nil

	local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

	local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
	fldr.Name = "DMYF"
	local CloneChar = DeadChar:Clone()
	local ANIMATIONHERE
	if CloneChar:FindFirstChild("Animate") then
		ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
		CloneChar:FindFirstChild("Animate"):Destroy()
	end
	if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
	if CloneChar.Torso:FindFirstChild("Neck") then
		local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
		Clonessss.Part0 = nil
		Clonessss.Part1 = DeadChar.Head
		Clonessss.Parent = DeadChar.Torso
	end
	CloneChar.Parent = fldr
	CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
	CloneChar.Humanoid.BreakJointsOnDeath = false
	CloneChar.Name = "non"
	CloneChar.Humanoid.DisplayDistanceType = "None"

	for _,v in next, DeadChar:GetChildren() do
		if v:IsA("Accessory") then
			local topacc = false
			if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
			v.Handle.Massless = true
			v.Handle.CanCollide = false

			local bv = Instance.new("BodyVelocity",v.Handle)
			bv.Velocity = Vector3.new(0,0,0)
			coroutine.wrap(function()
				if topacc then
					local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
					local normaltop = allthings[1].Attachment1
					local alipos = allthings[1]
					local alirot = allthings[2]
					local p0 = v.Handle
					local p1 = DeadChar.Head
					alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
					alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						coroutine.wrap(function()
							if alipos.Attachment1 == normaltop then
								p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
							else
								v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
							end
						end)()
					end
				else
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end)()
		end
	end

	local a = DeadChar.Torso
	local b = DeadChar.HumanoidRootPart
	local c = DeadChar.Humanoid
	a.Parent = game:FindFirstChildOfClass("Workspace")
	c.Parent = game:FindFirstChildOfClass("Workspace")
	local told = a:Clone()
	local told1 = c:Clone()
	b["RootJoint"].Part0 = told
	b["RootJoint"].Part1 = DeadChar.Head
	a.Name = "torso"
	a.Neck:Destroy()
	c.Name = "Mizt Hub Best"
	told.Parent = DeadChar
	told1.Parent = DeadChar
	DeadChar.PrimaryPart = told
	told1.Health = 0
	b:Destroy()
	a.Parent = DeadChar
	c.Parent = DeadChar
	told:Destroy()
	told1:Destroy()
	a.Name = "Torso"

	if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
	if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

	local Collider
	function UnCollide()
		if HumanDied then Collider:Disconnect(); return end
for _,Parts in next, CloneChar:GetChildren() do
if Parts:IsA("BasePart") then
Parts.CanCollide = false 
end 
end
		for _,Parts in next, DeadChar:GetChildren() do
			if Parts:IsA("BasePart") then
				Parts.CanCollide = false
			end 
		end 
	end
	Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

	local resetBindable = Instance.new("BindableEvent")
	resetBindable.Event:connect(function()
		game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
		resetBindable:Destroy()
		HumanDied = true
		pcall(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
			DeadChar.Head:Destroy()
			DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
			game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
			if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
		end)
	end)
	game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

	coroutine.wrap(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
				HumanDied = true
				pcall(function()
					game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
					DeadChar.Head:Destroy()
					DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
					game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
					if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
				end)
				if resetBindable then
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
				end
				break
			end
		end
	end)()


	SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
	SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
	SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
	SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
	SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
	SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

	for _,v in pairs(DeadChar:GetChildren()) do
		if v:IsA("BasePart") and v.Name ~= "Head" then
--[[local bv = Instance.new("BodyVelocity",v)
bv.Velocity = Vector3.new(0,0,0)
coroutine.wrap(function()
while true do
game:GetService("RunService").RenderStepped:wait()
if HumanDied then break end
v.CFrame = CloneChar[v.Name].CFrame
end
end)()]]
		elseif v:IsA("BasePart") and v.Name == "Head" then
			local bv = Instance.new("BodyVelocity",v)
			bv.Velocity = Vector3.new(0,0,0)
			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
				end
			end)()
		end
	end

	for _,BodyParts in next, CloneChar:GetDescendants() do
		if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
			BodyParts.Transparency = 1 end end
	game:GetService("RunService").RenderStepped:wait()
	game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
	game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

	for _,v in next, DeadChar:GetChildren() do
		if v:IsA("Accessory") then
			if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		end
	end

	if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end

else
end






Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character:FindFirstChildOfClass("Humanoid")
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Character)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

Animation_Speed = 3
Frame_Speed = 1 / 60
local Speed = 26
local SIZE = 1
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local ANIM = "Idle"
local ATTACK = false
local COMBO = 1
local Rooted = false
local SINE = 0
local CHANGE = 2 / Animation_Speed
local ROBLOXIDLEANIMATION = IT("Animation")
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "NAME"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local KILLCOUNT = 0

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
local NAMEBILL = Instance.new("BillboardGui",Character)
NAMEBILL.AlwaysOnTop = true
NAMEBILL.Size = UDim2.new(7,35,3,15)
NAMEBILL.StudsOffset = Vector3.new(0,2,0)
NAMEBILL.MaxDistance = 0
NAMEBILL.Adornee = Head
NAMEBILL.Name = "NameBillboard"
local NAMEMODE = Instance.new("TextLabel",NAMEBILL)
NAMEMODE.BackgroundTransparency = 1
NAMEMODE.TextScaled = false
NAMEMODE.BorderSizePixel = 0
NAMEMODE.Text = "Just a Banisher"
NAMEMODE.Font = "Cartoon"
NAMEMODE.TextSize = 75
NAMEMODE.TextStrokeTransparency = 0
NAMEMODE.Size = UDim2.new(1,0,0.5,0)
NAMEMODE.Parent = NAMEBILL
NAMEMODE.TextColor3 = Color3.fromRGB(200,200,200)
NAMEMODE.TextStrokeColor3 = Color3.new(69, 127, 186)
function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

local CHATBILL = Instance.new("BillboardGui",Character)
CHATBILL.AlwaysOnTop = true
CHATBILL.Size = UDim2.new(7,35,3,15)
CHATBILL.StudsOffset = Vector3.new(0,4,0)
CHATBILL.MaxDistance = 10000
CHATBILL.Adornee = Head
CHATBILL.Name = "NameBillboard"
local CHAT = Instance.new("TextLabel",CHATBILL)
CHAT.BackgroundTransparency = 1
CHAT.TextScaled = false
CHAT.BorderSizePixel = 0
CHAT.Text = "Welcum"
CHAT.Font = "Cartoon"
CHAT.TextSize = 40
CHAT.TextStrokeTransparency = 0
CHAT.Size = UDim2.new(1,0,0.5,0)
CHAT.Parent = CHATBILL
CHAT.TextColor3 = Color3.fromRGB(200,200,200)
CHAT.TextStrokeColor3 = Color3.new(69, 127, 186)
function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
function bosschat()
	CHAT.Transparency = 1
	CHAT.Text = Chat
	wait(2)
	Chat.Transparency = 0
end
local GUN = CreatePart(0, Character, "SmoothPlastic", 0, 1, "Bright blue", "GunPart", VT(1.1, 1.1, 1.1),false)
local gunweld = CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, GUN, CF(0*SIZE,-.5*SIZE,0*SIZE), CF(0, 0, 0))
local gunz = "Starslayer Railgun"
local athp1 = Instance.new("Attachment",GUN)
local atho1 = Instance.new("Attachment",GUN)
if gunz then
	Character[gunz].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp1
	Character[gunz].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho1
	atho1.Rotation = Vector3.new(0, 180, 320)
	athp1.Position = Vector3.new(-.5, -1.5, 0)
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end
function unanchor()
	if UNANCHOR == true then
		g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

RootPart.Size = RootPart.Size*SIZE
Torso.Size = Torso.Size*SIZE
RightArm.Size = RightArm.Size*SIZE
RightLeg.Size = RightLeg.Size*SIZE
LeftArm.Size = LeftArm.Size*SIZE
LeftLeg.Size = LeftLeg.Size*SIZE
RootJoint.C0 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
RootJoint.C1 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
Neck.C0 = NECKC0 * CF(0 * SIZE, 0 * SIZE, 0 + ((1 * SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))
Neck.C1 = CF(0 * SIZE, -0.5 * SIZE, 0 * SIZE) * ANGLES(RAD(-90), RAD(0), RAD(180))
RightShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
LeftShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
RightHip.C0 = CF(1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
LeftHip.C0 = CF(-1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
RightHip.C1 = CF(0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
LeftHip.C1 = CF(-0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
Head.Size = Head.Size*SIZE
RootJoint.Parent = RootPart
Neck.Parent = Torso
RightShoulder.Parent = Torso
LeftShoulder.Parent = Torso
RightHip.Parent = Torso
LeftHip.Parent = Torso



Humanoid.Parent = Character

Humanoid.Died:connect(function()
	ATTACK = true
end)


Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "1" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 2 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "2" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 3 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "3" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 4 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "4" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 128
		if mode == 1 then mode = 5 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "5" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 6 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "6" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 7 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "7" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 8 else mode = 1 end
	end
end)

Mouse.KeyDown:connect(function(NEWKEY)
	if NEWKEY == "8" and ATTACK == false then
		change = .85
		movement = 12
		Speed = 26
		if mode == 1 then mode = 9 else mode = 1 end
	end
end)

while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
		v:Stop();
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	local forwardvec =  math.clamp((Torso.Velocity*Torso.CFrame.lookVector).X+(Torso.Velocity*Torso.CFrame.lookVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local sidevec = math.clamp((Torso.Velocity*Torso.CFrame.rightVector).X+(Torso.Velocity*Torso.CFrame.rightVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local sidevelocity = sidevec/Humanoid.WalkSpeed
	local forwardvelocity = forwardvec/Humanoid.WalkSpeed
	if -RootPart.Velocity.Y / 1.5 > -5 and -RootPart.Velocity.Y / 1.5 < 150 then
		velocityYFall = RootPart.Velocity.Y / 1.5
	elseif -RootPart.Velocity.Y / 1.5 < -5 then
		velocityYFall = 5
	elseif -RootPart.Velocity.Y / 1.5 > 150 then
		velocityYFall = -150
	end
	if -RootPart.Velocity.Y / 180 > 0 and -RootPart.Velocity.Y / 180 < 1.2 then
		velocityYFall2 = RootPart.Velocity.Y / 180
	elseif -RootPart.Velocity.Y / 180 < 0 then
		velocityYFall2 = 0
	elseif -RootPart.Velocity.Y / 180 > 1.2 then
		velocityYFall2 = -1.2
	end
	if -RootPart.Velocity.Y / 1.5 > -5 and -RootPart.Velocity.Y / 1.5 < 50 then
		velocityYFall3 = RootPart.Velocity.Y / 1.5
	elseif -RootPart.Velocity.Y / 1.5 < -5 then
		velocityYFall3 = 5
	elseif -RootPart.Velocity.Y / 1.5 > 50 then
		velocityYFall3 = -50
	end
	if -RootPart.Velocity.Y / 1.5 > -50 and -RootPart.Velocity.Y / 1.5 < 20 then
		velocityYFall4 = RootPart.Velocity.Y / 1.5
	elseif -5 > -RootPart.Velocity.Y / 180 then
		velocityYFall4 = 5
	elseif -RootPart.Velocity.Y / 180 > 50 then
		velocityYFall4 = -50
	end
	if RootPart.RotVelocity.Y / 6 < 1 and RootPart.RotVelocity.Y / 6 > -1 then
		neckrotY = RootPart.RotVelocity.Y / 6
	elseif RootPart.RotVelocity.Y / 6 < -1 then
		neckrotY = -1
	elseif RootPart.RotVelocity.Y / 6 > 1 then
		neckrotY = 1
	end
	if RootPart.RotVelocity.Y / 8 < 0.6 and RootPart.RotVelocity.Y / 8 > -0.6 then
		neckrotY2 = RootPart.RotVelocity.Y / 8
	elseif RootPart.RotVelocity.Y / 8 < -0.6 then
		neckrotY2 = -0.6
	elseif RootPart.RotVelocity.Y / 8 > 0.6 then
		neckrotY2 = 0.6
	end
	if RootPart.RotVelocity.Y / 6 < 0.2 and RootPart.RotVelocity.Y / 6 > -0.2 then
		torsorotY = RootPart.RotVelocity.Y / 6
	elseif RootPart.RotVelocity.Y / 6 < -0.2 then
		torsorotY = -0.2
	elseif RootPart.RotVelocity.Y / 6 > 0.2 then
		torsorotY = 0.2
	end
	if RootPart.RotVelocity.Y / 8 < 0.2 and RootPart.RotVelocity.Y / 8 > -0.2 then
		torsorotY2 = RootPart.RotVelocity.Y / 8
	elseif RootPart.RotVelocity.Y / 8 < -0.2 then
		torsorotY2 = -0.2
	elseif RootPart.RotVelocity.Y / 8 > 0.2 then
		torsorotY2 = 0.2
	end
	torsoY = -(Torso.Velocity * Vector3.new(1, 0, 1)).magnitude / 20
	torsoY2 = -(Torso.Velocity * Vector3.new(1, 0, 1)).magnitude / 36
	local rightvector = (RootPart.Velocity * RootPart.CFrame.rightVector).X + (RootPart.Velocity * RootPart.CFrame.rightVector).Z
	local lookvector = (RootPart.Velocity * RootPart.CFrame.lookVector).X + (RootPart.Velocity * RootPart.CFrame.lookVector).Z
	if lookvector > Humanoid.WalkSpeed then
		lookvector = Humanoid.WalkSpeed
	end
	if lookvector < -Humanoid.WalkSpeed then
		lookvector = -Humanoid.WalkSpeed
	end
	if rightvector > Humanoid.WalkSpeed then
		rightvector = Humanoid.WalkSpeed
	end
	if rightvector < -Humanoid.WalkSpeed then
		rightvector = -Humanoid.WalkSpeed
	end
	local lookvel = lookvector / Humanoid.WalkSpeed
	local rightvel = rightvector / Humanoid.WalkSpeed
	local leftlegheight,rightlegheight = 0,0
	local Rray,Lray = Ray.new(RightLeg.Position,RightLeg.CFrame.UpVector.Unit*-2),Ray.new(LeftLeg.Position,LeftLeg.CFrame.UpVector.Unit*-2)
	local rp,Rpos = workspace:FindPartOnRayWithIgnoreList(Rray,{Character},false,true)
	local lp,Lpos = workspace:FindPartOnRayWithIgnoreList(Lray,{Character},false,true)
	leftlegheight,rightlegheight = 0,0
	if rp then   rightlegheight = (RightLeg.Position-Rpos).Magnitude-.95   end
	if lp then   leftlegheight = (LeftLeg.Position-Lpos).Magnitude-.95   end
	if HITFLOOR == nil then
		ANIM = "Midair"
		if ATTACK == false then
			if mode == 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 20), 0*SIZE+0 * COS(SINE / 20), 2*SIZE+0.5 * COS(SINE / 20)) * ANGLES(RAD(0+0 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30)), RAD(0+260.24 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 20), 0.35*SIZE+0 * COS(SINE / 20), 0*SIZE+0 * COS(SINE / 20)) * ANGLES(RAD(0+0 * COS(SINE / 10)), RAD(0+0 * COS(SINE / 10)), RAD(-90+0 * COS(SINE / 10))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 10), 0.36*SIZE+0 * COS(SINE / 10), 0*SIZE+0 * COS(SINE / 10)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(90+0 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)

			elseif mode == 2 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -1, 0) * ANGLES(math.rad(-(change * 20) - movement / 20 * math.cos(SINE / 2)) * (lookvector / (Humanoid.WalkSpeed * 2)) + math.rad(velocityYFall3 / 10), math.rad(0), math.rad(-(change * 20) - movement / 20 * math.cos(SINE / 2)) * (rightvector / (Humanoid.WalkSpeed * 2))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.55 - velocityYFall3 / 70, 0) * ANGLES(math.rad(-velocityYFall3 / 10), math.rad(0), math.rad(-velocityYFall)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.55 - velocityYFall3 / 70, 0) * ANGLES(math.rad(-velocityYFall3 / 10), math.rad(0), math.rad(velocityYFall)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5, 0, -0.8) * ANGLES(math.rad(-25), math.rad(0), math.rad(2)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925, 0) * ANGLES(math.rad(-35), math.rad(0), math.rad(-2)), 0.2 / Animation_Speed)
			end end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
			if mode == 1 then
				sick.SoundId = "rbxassetid://1167756502"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 30
				NAMEMODE.Text = "Just a Banisher"
				NAMEMODE.Font = "Cartoon"
				NAMEMODE.TextColor3 = Color3.fromRGB(69, 127, 186)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)

				CHAT.Text = "Made By Chara"
				CHAT.Font = "Cartoon"
				CHAT.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				CHAT.TextColor3 = Color3.fromRGB(69, 127, 186)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 20), 0*SIZE+0 * COS(SINE / 20), 2*SIZE+0.5 * COS(SINE / 20)) * ANGLES(RAD(0+0 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30)), RAD(0+260.24 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 20), 0.35*SIZE+0 * COS(SINE / 20), 0*SIZE+0 * COS(SINE / 20)) * ANGLES(RAD(0+0 * COS(SINE / 10)), RAD(0+0 * COS(SINE / 10)), RAD(-90+0 * COS(SINE / 10))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 10), 0.36*SIZE+0 * COS(SINE / 10), 0*SIZE+0 * COS(SINE / 10)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(90+0 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)

			elseif mode == 2 then
				sick.SoundId = "rbxassetid://6215267007"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 16
				NAMEMODE.Text = "Waiting"
				NAMEMODE.Font = "Antique"
				NAMEMODE.TextColor3 = Color3.fromRGB(189, 25, 78)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)

				CHAT.Text = "Damn thats taking long"
				CHAT.Font = "Antique"
				CHAT.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				CHAT.TextColor3 = Color3.fromRGB(69, 127, 186)

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 6), 0*SIZE+-0.15 * COS(SINE / 6), 0*SIZE+0.1 * COS(SINE / 6)) * ANGLES(RAD(0+3.5 * COS(SINE / 12)), RAD(0+0 * COS(SINE / 12)), RAD(0+0 * COS(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 7), 0.5*SIZE+-0.15 * COS(SINE / 7), 0*SIZE+0.1 * COS(SINE / 7)) * ANGLES(RAD(-5+-15 * COS(SINE / 12)), RAD(-15+-7.5 * COS(SINE / 12)), RAD(-1.5+0 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65*SIZE-0 * COS(SINE / 6), -0.25*SIZE+0.15 * COS(SINE / 6), 0.2*SIZE+0 * COS(SINE / 6)) * ANGLES(RAD(170+-2.5 * COS(SINE / 5)), RAD(-15+0 * COS(SINE / 5)), RAD(-5+0 * COS(SINE / 5))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 6), -1*SIZE+0.1 * COS(SINE / 6), 0*SIZE+-0.01 * COS(SINE / 6)) * ANGLES(RAD(3.5+3.5 * COS(SINE / 12)), RAD(100+0 * COS(SINE / 12)), RAD(-8+0 * COS(SINE / 12))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 6), -1*SIZE+-0.1 * COS(SINE / 6), -0.01*SIZE+-0.01 * COS(SINE / 6)) * ANGLES(RAD(3.5+3.5 * COS(SINE / 12)), RAD(-66+0 * COS(SINE / 12)), RAD(0+-8 * COS(SINE / 12))), 1 / Animation_Speed)

			elseif mode == 3 then
				sick.SoundId = "rbxassetid://481104377"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "Cannon"
				NAMEMODE.Font = "TitilliumWeb"
				NAMEMODE.TextColor3 = Color3.fromRGB(245, 240, 240)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)

				CHAT.Text = ""
				CHAT.Font = "Antique"
				CHAT.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				CHAT.TextColor3 = Color3.fromRGB(96,126,100)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 15), 0*SIZE+0 * COS(SINE / 15), 3*SIZE+0.5 * COS(SINE / 15)) * ANGLES(RAD(0+0 * COS(SINE / 30)), RAD(0+-10 * COS(SINE / 30)), RAD(0.7+3 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 30), 0.5*SIZE+0 * COS(SINE / 30), 0*SIZE+0 * COS(SINE / 30)) * ANGLES(RAD(10+0 * COS(SINE / 30)), RAD(-5+-5 * COS(SINE / 30)), RAD(10+15 * COS(SINE / 30))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(135+-15 * COS(SINE / 30)), RAD(-25+0 * COS(SINE / 30)), RAD(-25+15 * COS(SINE / 30))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.01*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-10+0 * COS(SINE / 15)), RAD(80+0 * COS(SINE / 15)), RAD(10+10 * COS(SINE / 15))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.01*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 15)), RAD(-80+0 * COS(SINE / 15)), RAD(-10+-10 * COS(SINE / 15))), 1 / Animation_Speed)

			elseif mode == 4 then
				sick.SoundId = "rbxassetid://171230598"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "Vaporwave"
				NAMEMODE.Font = "LuckiestGuy"
				NAMEMODE.TextColor3 = Color3.fromRGB(221,196,252)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)

				CHAT.Text = ""
				CHAT.Font = "LuckiestGuy"
				CHAT.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				CHAT.TextColor3 = Color3.fromRGB(221,196,252)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 18), 0*SIZE+0 * COS(SINE / 18), 2*SIZE+1 * COS(SINE / 18)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(180+24 * COS(SINE / 1)), RAD(0+24 * COS(SINE / 1)), RAD(-25+24 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(180+-24 * COS(SINE / 1)), RAD(0+-24 * COS(SINE / 1)), RAD(25+-24 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 18)), RAD(-20+1 * COS(SINE / 18)), RAD(-80+0 * COS(SINE / 18))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.7*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 18)), RAD(-25+1 * COS(SINE / 18)), RAD(80+0 * COS(SINE / 18))), 1 / Animation_Speed)


			elseif mode == 5 then
				sick.SoundId = "rbxassetid://2920078671"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "FAST BOII"
				NAMEMODE.Font = "LuckiestGuy"
				NAMEMODE.TextColor3 = Color3.fromRGB(226, 237, 109)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)

				CHAT.Text = "Speed"
				CHAT.Font = "LuckiestGuy"
				CHAT.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				CHAT.TextColor3 = Color3.fromRGB(226, 237, 109)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), -0.2*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-6+360 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+-75 * COS(SINE / 5)), RAD(0+0 * COS(SINE / 5)), RAD(0+0 * COS(SINE / 5))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+75 * COS(SINE / 5)), RAD(0+0 * COS(SINE / 5)), RAD(0+0 * COS(SINE / 5))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.01*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+75 * COS(SINE / 5)), RAD(90+0 * COS(SINE / 5)), RAD(0+0 * COS(SINE / 5))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.01*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+-75 * COS(SINE / 5)), RAD(-90+0 * COS(SINE / 5)), RAD(0+0 * COS(SINE / 5))), 1 / Animation_Speed)


			elseif mode == 6 then
				sick.SoundId = "rbxassetid://151915559"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "Light"
				NAMEMODE.Font = "TitilliumWeb"
				NAMEMODE.TextColor3 = Color3.fromRGB(245, 240, 240)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)

				CHAT.Text = ""
				CHAT.Font = "LuckiestGuy"
				CHAT.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				CHAT.TextColor3 = Color3.fromRGB(245, 240, 240)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 18), 0*SIZE+0 * COS(SINE / 18), 2*SIZE+1 * COS(SINE / 18)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 12), 0.5*SIZE+0.05 * COS(SINE / 12), 0*SIZE+0 * COS(SINE / 12)) * ANGLES(RAD(0+0 * COS(SINE / 12)), RAD(0+0 * COS(SINE / 12)), RAD(15+3 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 12), 0.5*SIZE+0.05 * COS(SINE / 12), 0*SIZE+0 * COS(SINE / 12)) * ANGLES(RAD(160+4 * COS(SINE / 62)), RAD(0+0 * COS(SINE / 62)), RAD(-15+-3 * COS(SINE / 62))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-17+9.4 * COS(SINE / 26)), RAD(80+0 * COS(SINE / 26)), RAD(0+0 * COS(SINE / 26))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -0.5*SIZE+0 * COS(SINE / 1), -0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-22+10.8 * COS(SINE / 32)), RAD(-80+0 * COS(SINE / 32)), RAD(0+0 * COS(SINE / 32))), 1 / Animation_Speed)

			elseif mode == 7 then
				sick.SoundId = "rbxassetid://929041894"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "Overlord"
				NAMEMODE.Font = "Antique"
				NAMEMODE.TextColor3 = Color3.fromRGB(1,0,0)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(1,1,1)

				CHAT.Text = ""
				CHAT.Font = "Antique"
				CHAT.TextStrokeColor3 = Color3.fromRGB(1,1,1)
				CHAT.TextColor3 = Color3.fromRGB(1,0,0)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 63), 0*SIZE+0 * COS(SINE / 63), 30*SIZE+10 * COS(SINE / 63)) * ANGLES(RAD(0+5 * COS(SINE / 30)), RAD(0+4 * COS(SINE / 30)), RAD(0+4 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 43), 0.2*SIZE+-0.4 * COS(SINE / 43), 0*SIZE+0.1 * COS(SINE / 43)) * ANGLES(RAD(0+10 * COS(SINE / 43)), RAD(0+10 * COS(SINE / 43)), RAD(10+-10 * COS(SINE / 43))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 43), 0.2*SIZE+-0.4 * COS(SINE / 43), 0*SIZE+0.1 * COS(SINE / 43)) * ANGLES(RAD(0+10 * COS(SINE / 43)), RAD(0+10 * COS(SINE / 43)), RAD(-10+10 * COS(SINE / 43))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 43), -1*SIZE+-0.05 * COS(SINE / 43), -0.01*SIZE+-0.01 * COS(SINE / 43)) * ANGLES(RAD(-10+0 * COS(SINE / 43)), RAD(85+0 * COS(SINE / 43)), RAD(-10+-3 * COS(SINE / 43))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 43), -0.5*SIZE+-0.05 * COS(SINE / 43), -0.5*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(0+0 * COS(SINE / 43)), RAD(-85+0 * COS(SINE / 43)), RAD(10+-3 * COS(SINE / 43))), 1 / Animation_Speed)

			elseif mode == 8 then
				sick.SoundId = "rbxassetid://5187284323"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "Skylight"
				NAMEMODE.Font = "GothamSemibold"
				NAMEMODE.TextColor3 = Color3.fromRGB(200, 200, 200)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(216, 147, 219)

				CHAT.Text = ""
				CHAT.Font = "GothamSemibold"
				CHAT.TextStrokeColor3 = Color3.fromRGB(1,1,1)
				CHAT.TextColor3 = Color3.fromRGB(1,0,0)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 30), 0*SIZE+0 * COS(SINE / 30), 2*SIZE+0.2 * COS(SINE / 30)) * ANGLES(RAD(-5+4 * COS(SINE / 24)), RAD(0+7 * COS(SINE / 24)), RAD(0+5 * COS(SINE / 24))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 23), 0.5*SIZE+0.2 * COS(SINE / 23), 0*SIZE+0 * COS(SINE / 23)) * ANGLES(RAD(-10+3 * COS(SINE / 30)), RAD(-30+8 * COS(SINE / 30)), RAD(15+5 * COS(SINE / 30))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.3*SIZE-0 * COS(SINE / 35), 0.5*SIZE+0.2 * COS(SINE / 35), -0.6*SIZE+0 * COS(SINE / 35)) * ANGLES(RAD(160+10 * COS(SINE / 33)), RAD(-30+8 * COS(SINE / 33)), RAD(15+5 * COS(SINE / 33))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 32), -0.6*SIZE+0.2 * COS(SINE / 32), -0.5*SIZE+0.1 * COS(SINE / 32)) * ANGLES(RAD(-20+10 * COS(SINE / 32)), RAD(80+10 * COS(SINE / 32)), RAD(5+3 * COS(SINE / 32))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 30), -0.8*SIZE+0.2 * COS(SINE / 30), 0.2*SIZE+0.1 * COS(SINE / 30)) * ANGLES(RAD(-30+7 * COS(SINE / 34)), RAD(-80+5 * COS(SINE / 34)), RAD(0+0 * COS(SINE / 34))), 1 / Animation_Speed)

            elseif mode == 9 then
				sick.SoundId = "rbxassetid://630256790"
				sick.Pitch = 1
				Humanoid.WalkSpeed = 32
				NAMEMODE.Text = "Fire"
				NAMEMODE.Font = "SourceSansItalic"
				NAMEMODE.TextColor3 = Color3.fromRGB(212, 143, 74)
				NAMEMODE.TextStrokeColor3 = Color3.fromRGB(200, 200, 200)
				
				CHAT.Text = ""
				CHAT.Font = "SourceSansItalic"
				CHAT.TextStrokeColor3 = Color3.fromRGB(1,1,1)
				CHAT.TextColor3 = Color3.fromRGB(1,0,0)
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 39), 0*SIZE+0 * COS(SINE / 39), 0*SIZE+0.1 * COS(SINE / 39)) * ANGLES(RAD(0+5 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30)), RAD(20+5 * COS(SINE / 30))), 1 / Animation_Speed)
		     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55*SIZE-0 * COS(SINE / 36), 0.3*SIZE+0.2 * COS(SINE / 36), 0.3*SIZE+0 * COS(SINE / 36)) * ANGLES(RAD(10+0 * COS(SINE / 32.5)), RAD(-20+5 * COS(SINE / 32.5)), RAD(10+10 * COS(SINE / 32.5))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		    	LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.55*SIZE-0 * COS(SINE / 36), 0.3*SIZE+0.2 * COS(SINE / 36), 0*SIZE+0 * COS(SINE / 36)) * ANGLES(RAD(10+0 * COS(SINE / 32.5)), RAD(10+-5 * COS(SINE / 32.5)), RAD(-10+-10 * COS(SINE / 32.5))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		    	RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 39), -1*SIZE+-0.1 * COS(SINE / 39), -0.5*SIZE+0 * COS(SINE / 39)) * ANGLES(RAD(-5+5 * COS(SINE / 39)), RAD(70+0 * COS(SINE / 39)), RAD(0+0 * COS(SINE / 39))), 1 / Animation_Speed)
		    	LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 39), -1*SIZE+-0.1 * COS(SINE / 39), 0.1*SIZE+0 * COS(SINE / 39)) * ANGLES(RAD(5+0 * COS(SINE / 42)), RAD(-100+0 * COS(SINE / 42)), RAD(5+5 * COS(SINE / 42))), 1 / Animation_Speed)
			end end

	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			if mode == 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(90+0 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30)), RAD(0+360 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(-90+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(90+0 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -0.8*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(90+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -0.8*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(-90+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			elseif mode == 2 or mode == 9 then

				gunweld.C0 = Clerp(gunweld.C0, CF(0*SIZE+0 * COS(SINE / 15), 0*SIZE-0 * COS(SINE /15), 0*SIZE+0 * COS(SINE / 15)) * ANGLES(RAD(-0+0 * COS(SINE / 505)), RAD(-0+0* COS(SINE / 55)), RAD(0-0 * COS(SINE / 15))), 1 / Animation_Speed)

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -1.05 + change / 2 * math.cos(SINE /2), 0) * ANGLES(math.rad((change * 20) - movement / 20 * math.cos(SINE /2)) * lookvel, torsorotY2 + math.rad(0 - 4 * math.sin(SINE /4)), math.rad(-(change * 20) - movement / 20 * math.cos(SINE /2)) * rightvel + torsorotY2 + math.rad(0 - 1 * math.cos(SINE /4))) * ANGLES(math.rad(0),-math.rad(10+10 * math.cos(SINE/WALKSPEEDVALUE))*sidevelocity,math.rad(0)), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.85 + movement / 15 * math.cos(SINE /4) / 2, (-0.1 - movement / 15 * math.cos(SINE /4)) * (0.5 + 0.5 * lookvel)) * ANGLES((math.rad(-10 * lookvel + change * 5 + movement * math.cos(SINE /4)) + movement / 10 * math.sin(SINE /4)) * lookvel, math.rad(0 + movement * 2 * math.cos(SINE /4)), (math.rad(change * 5 + movement * math.cos(SINE /4)) + movement / 10 * math.sin(SINE /4)) * (rightvector / (Humanoid.WalkSpeed * 2))),1)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.85 - movement / 15 * math.cos(SINE /4) / 2, (-0.1 + movement / 15 * math.cos(SINE /4)) * (0.5 + 0.5 * lookvel)) * ANGLES((math.rad(-10 * lookvel + change * 5 - movement * math.cos(SINE /4)) + -(movement / 10) * math.sin(SINE /4)) * lookvel, math.rad(0 + movement * 2 * math.cos(SINE /4)), (math.rad(change * 5 - movement * math.cos(SINE /4)) + -(movement / 10) * math.sin(SINE /4)) * (rightvector / (Humanoid.WalkSpeed * 2))),1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.12 * lookvel ^ 2 - movement / 40 * math.cos(SINE /4) / 3, movement / 150 + movement / 40 * math.cos(SINE /4)) * CFrame.Angles((math.rad(-5 - movement * 2 * math.cos(SINE /4)) + -(movement / 10) * math.sin(SINE /4)) * lookvel, math.rad(0 - movement * 2 * math.cos(SINE /4)), -math.rad(movement * 1 * 0.2 - movement * 1 * math.cos(SINE /2) * lookvel) + math.rad(-5 * rightvel)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 14), 0*SIZE+-0.3 * COS(SINE / 14), 0*SIZE+0 * COS(SINE / 14)) * ANGLES(RAD(130+10 * COS(SINE / 12)), RAD(-10+5 * COS(SINE / 12)), RAD(-10+5 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			elseif mode == 3 then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 15), 0*SIZE+0 * COS(SINE / 15), 3*SIZE+0.5 * COS(SINE / 15)) * ANGLES(RAD(40+0 * COS(SINE / 30)), RAD(0+-5 * COS(SINE / 30)), RAD(0+0 * COS(SINE / 30))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-45+0 * COS(SINE / 19)), RAD(5+2 * COS(SINE / 19)), RAD(0.7+3 * COS(SINE / 19))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-45+0 * COS(SINE / 19)), RAD(-5+-2 * COS(SINE / 19)), RAD(0.7+3 * COS(SINE / 19))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -0.5*SIZE+0 * COS(SINE / 1), -0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-20+9 * COS(SINE / 37)), RAD(80+0 * COS(SINE / 37)), RAD(0+5 * COS(SINE / 37))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-20+-9 * COS(SINE / 37)), RAD(-80+0 * COS(SINE / 37)), RAD(0+-5 * COS(SINE / 37))), 1 / Animation_Speed)
			elseif mode == 4 then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 18), 0*SIZE+0 * COS(SINE / 18), 2*SIZE+1 * COS(SINE / 18)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+1 * COS(SINE / 1)) * ANGLES(RAD(180+24 * COS(SINE / 1)), RAD(0+24 * COS(SINE / 1)), RAD(-25+24 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+1 * COS(SINE / 1)) * ANGLES(RAD(180+-24 * COS(SINE / 1)), RAD(0+-24 * COS(SINE / 1)), RAD(25+-24 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 18)), RAD(-20+1 * COS(SINE / 18)), RAD(-80+0 * COS(SINE / 18))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.7*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 18)), RAD(-25+1 * COS(SINE / 18)), RAD(80+0 * COS(SINE / 18))), 1 / Animation_Speed)
			elseif mode == 5 then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), -0.2*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-45+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-135+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-135+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.01*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+75 * COS(SINE / 2)), RAD(90+0 * COS(SINE / 2)), RAD(0+0 * COS(SINE / 2))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), -0.01*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+-75 * COS(SINE / 2)), RAD(-90+0 * COS(SINE / 2)), RAD(0+0 * COS(SINE / 2))), 1 / Animation_Speed)
			elseif mode == 6 then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0.25 * COS(SINE / 53), 0.92*SIZE+0 * COS(SINE / 53), 4*SIZE+-2 * COS(SINE / 53)) * ANGLES(RAD(70+0 * COS(SINE / 47)), RAD(0+0 * COS(SINE / 47)), RAD(4.5+3 * COS(SINE / 47))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-25+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(-45+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 12)), RAD(0+0 * COS(SINE / 12)), RAD(-12+4.1 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 12), -0.5*SIZE+-0.02 * COS(SINE / 12), -0.5*SIZE+0 * COS(SINE / 12)) * ANGLES(RAD(-10+-2.5 * COS(SINE / 21)), RAD(90+0 * COS(SINE / 21)), RAD(0+0 * COS(SINE / 21))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 12), -1*SIZE+-0.02 * COS(SINE / 12), -0.01*SIZE+-0.01 * COS(SINE / 12)) * ANGLES(RAD(-20+-2.5 * COS(SINE / 51)), RAD(-90+0 * COS(SINE / 51)), RAD(0+0 * COS(SINE / 51))), 1 / Animation_Speed)
			elseif mode == 7 then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 63), 0*SIZE+0 * COS(SINE / 63), 30*SIZE+10 * COS(SINE / 63)) * ANGLES(RAD(40+10 * COS(SINE / 45)), RAD(0+4 * COS(SINE / 45)), RAD(0+4 * COS(SINE / 45))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 43), 0.4*SIZE+0.1 * COS(SINE / 43), 0*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(-20+0 * COS(SINE / 41)), RAD(3+0 * COS(SINE / 41)), RAD(7+-7 * COS(SINE / 41))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 43), 0.4*SIZE+-0.1 * COS(SINE / 43), 0.1*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(-20+0 * COS(SINE / 41)), RAD(-3+0 * COS(SINE / 41)), RAD(-7+7 * COS(SINE / 41))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 43), -1*SIZE+-0.05 * COS(SINE / 43), 0*SIZE+-0.01 * COS(SINE / 43)) * ANGLES(RAD(-10+-3 * COS(SINE / 43)), RAD(85+0 * COS(SINE / 43)), RAD(0+0 * COS(SINE / 43))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 43), -0.5*SIZE+0.05 * COS(SINE / 43), -0.5*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(0+0 * COS(SINE / 43)), RAD(-85+0 * COS(SINE / 43)), RAD(20+0 * COS(SINE / 43))), 1 / Animation_Speed)
			elseif mode == 8 then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 2*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(40+10 * COS(SINE / 33)), RAD(0+4 * COS(SINE / 33)), RAD(0+4 * COS(SINE / 33))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 43), 0.4*SIZE+-0.1 * COS(SINE / 43), 0.1*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(-20+0 * COS(SINE / 41)), RAD(-3+0 * COS(SINE / 41)), RAD(7+-5 * COS(SINE / 41))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4*SIZE-0 * COS(SINE / 35), 0.8*SIZE+0.2 * COS(SINE / 35), -0.6*SIZE+0 * COS(SINE / 35)) * ANGLES(RAD(160+10 * COS(SINE / 33)), RAD(20+-10 * COS(SINE / 33)), RAD(10+5 * COS(SINE / 33))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE+0 * COS(SINE / 43), -1*SIZE+-0.05 * COS(SINE / 43), -0.01*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(-10+0 * COS(SINE / 43)), RAD(85+0 * COS(SINE / 43)), RAD(-20+-3 * COS(SINE / 43))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE+0 * COS(SINE / 43), -0.5*SIZE+-0.05 * COS(SINE / 43), -0.5*SIZE+0 * COS(SINE / 43)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(-85+0 * COS(SINE / 1)), RAD(20+0 * COS(SINE / 1))), 1 / Animation_Speed)
			end end
		unanchor()
		Humanoid.MaxHealth = 5e7
		Humanoid.Health = 5e7
		Humanoid.Name = "Coolguy"
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 3
		sick:Resume()
		sick.Parent = Torso
		Humanoid.JumpPower = 55
	end 
	Humanoid.CameraOffset = Vector3.new(0, Torso.Position.Y - RootPart.Position.Y, 0)
end
